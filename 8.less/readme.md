## Вопросы
1. Observability сервисов. SLA / SLO / SLI. Показатели SLO для API.
   https://www.atlassian.com/ru/incident-management/kpis/sla-vs-slo-vs-sli
   https://etogeek.dev/posts/sli-slo-sla/
   https://teletype.in/@flow_russian/6fZTECzIinx
   https://habr.com/ru/companies/otus/articles/676342/  
   Показатели SLO для API:
   * Доступность (Availability):
     * Процент времени, когда API доступен и отвечает на запросы.
     * Пример: "API должен быть доступен 99.9% времени в течение месяца".
   * Латентность (Latency):
     * Время отклика API на запросы.
     * Пример: "95% запросов должны обрабатываться менее чем за 200 мс".
   * Пропускная способность (Throughput):
     * Количество запросов, которое API может обработать за определенное время.
     * Пример: "API должен обрабатывать не менее 1000 запросов в секунду".
   * Частота ошибок (Error Rate):
     * Процент запросов, которые завершаются ошибкой.
     * Пример: "Не более 0.1% запросов должны завершаться ошибкой".
   * Консистентность данных (Data Consistency):
     * Точность и согласованность данных, возвращаемых API.
     * Пример: "99.99% запросов должны возвращать согласованные данные".
   * Время восстановления (Time to Recovery):
     * Время, необходимое для восстановления API после сбоя.
     * Пример: "Восстановление после критического сбоя должно происходить в течение 5 минут".
   * Успешность обновлений (Deployment Success Rate):
     * Процент успешных развертываний новых версий API.
     * Пример: "99% развертываний должны быть успешными без влияния на пользователей".
2. RED-метрики.
   https://habr.com/ru/companies/otus/articles/514916/
   * Rate (Частота):
     * Это количество запросов, обрабатываемых сервисом за единицу времени.
     * Обычно измеряется в запросах в секунду (RPS).
     * Пример: 100 запросов в секунду.
   * Errors (Ошибки):
     * Количество неудачных запросов.
     * Обычно выражается как процент от общего числа запросов.
     * Пример: 1% запросов завершаются с ошибкой.
   * Duration (Длительность):
     * Время, необходимое для обработки запроса.
     * Обычно измеряется в миллисекундах.
     * Важно отслеживать не только среднее время, но и перцентили (например, 95-й, 99-й).
     * Пример: 95% запросов обрабатываются менее чем за 200 мс.
3. Протокол HTTP. HTTP 1.1 / HTTP 2 / HTTP 3 (QUIC). OpenAPI спецификация    
   https://sidharth-padhee.medium.com/http-1-1-vs-2-vs-3-quic-b9e80748625f      
   https://translated.turbopages.org/proxy_u/en-ru.ru.39e36427-66d691d2-df7d7e88-74722d776562/https/www.baeldung.com/cs/http-versions      
   https://mikeralphson.github.io/OpenAPI-Specification/oas/latest.html   
   https://habr.com/ru/companies/ozontech/articles/825008/
   
4. Протокол gRPC. Protobuf. gRPC Gateway   
   https://habr.com/ru/companies/otus/articles/780720/  
   https://protobuf.dev/getting-started/gotutorial/   
   https://habr.com/ru/articles/658769/   
   https://earthly.dev/blog/golang-grpc-gateway/      
5. Авторизация и аутентификация. JWT.
   https://dekh.medium.com/the-complete-guide-to-json-web-tokens-jwt-and-token-based-authentication-32501cb5125c   
   https://zhashkevych.medium.com/jwt-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B4%D0%BB%D1%8F-%D0%B2%D0%B0%D1%88%D0%B5%D0%B3%D0%BE-api-%D0%BD%D0%B0-go-80325de8691b   
   https://ru.hexlet.io/courses/go-web-development/lessons/auth/theory_unit

## Практика
### Задание
Спроектировать и реализовать gRPC для простого группового мессенджера

### Основные сущности
* Сессия пользователя. Уникальный UUID сессии и псевдоним
* Чат. Уникальный UUID чата. Каждый чат имеет набор характеристик, которые указываются при создании чата
* Сообщение в чате

### Пользователь
* Пользователь характеризуется только своим уникальным UUID сессии. При создании сессии пользователь имеет возможность указать псевдоним для отображения в истории сообщений.

### Чат
* Пользователь может создать неограниченное число чатов.
* При создании чата можно указать
  * Размер истории чата (целое число > 0). При превышении лимита сообщений старые сообщения удаляются
  * TTL. Время жизни чата. После наступления финишного времени (время создания чата + TTL) все пользователи, пытающиеся написать или прочитать сообщение из чата получают ошибку.
  * Read-Only. В чат с типом read only сообщения может писать только создатель чата, читать при этом могут все пользователи
  * Private. При создании приватного чата, пользователи должны предварительно отправить запрос на присоединение к чату. Владелец чата может получить список запросов на подключение и предоставить доступ выбранным пользователям.
* Создатель чата в любой момент может его удалить или выставить TTL уже после его создания. При указании TTL после создания, считаем время удаления не от момента создания чата, а от момента выставления TTL.


### Сообщение
* Любой пользователь может отправить сообщение в любой публичный чат по его UUID.
* Любой пользователь может получить историю сообщений в чате.
* В сообщении указывается сам текст сообщения, время его отправки и псевдоним пользователя. Если псевдоним не указан, то отображается "Аноним #N", где N автоматически инкрементируется для каждого анонимного пользователя в чате


Все данные хранятся in-memory, при этом иметь возможность для расширения и использования, при необходимости, стороннего стораджа (Redis / SQL)

### Прочие требования

При запуске сервиса с чатом, необходимо через флаги указать порт для gRPC, максимальный размер одного чата (по количеству сообщений) и максимальное количество чатов вообще.

Проект должен соответствовать структуре Go Project Layout

Должен быть билд Docker-образа

Должен быть реализован Graceful Shutdown и Health Check API

Все методы должны возвращать корректные коды ошибок.

Должно быть логирование всех реквестов и респонсов

Должна быть корректная обработка ошибок и паник.

Сервис должен корректно собирать и отдавать RED-метрики

Функционал должен быть покрыт тестами

К проекту должен быть подключен линтер golangci-lint

У проекта должен быть Makefile для билда, запуска тестов и запуска линтера, код интерфейса сервера должен генерироваться автоматически через go:generate

### Дополнительные требования

* Должно быть аналогичное HTTP API, описанное через формат OpenAPI (spec-first, то есть генерим код по спецификации, а не спецификацию по готовому коду), а бизнес логика - в одном месте с использованием grpc-gateway
* По умолчанию - in-memory, но через флаг --redis --dsn="redis dsn" или --postgres --dsn="postgresql dsn" должен использоваться другой сторадж




### Запуск docker
```make docker-build```
затем
```make docker-run ARGS="--grpc-port=50052"```   
либо любой другой аргумент из конфига